<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [OAI-implementers] custom error reporting, records in which
 sets.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:simeon%40cs.cornell.edu">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000599.html">
   <LINK REL="Next"  HREF="000602.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[OAI-implementers] custom error reporting, records in which
 sets.
   </H1>
    <B>Simeon Warner
    </B> 
    <A HREF="mailto:simeon%40cs.cornell.edu"
       TITLE="[OAI-implementers] custom error reporting, records in which
 sets.">simeon@cs.cornell.edu
       </A><BR>
    <I>Tue, 23 Jul 2002 11:08:11 -0400 (EDT)</I>
    <P><UL>
        <LI> Previous message: <A HREF="000599.html">[OAI-implementers] custom error reporting, records in which sets.
</A></li>
        <LI> Next message: <A HREF="000602.html">[OAI-implementers] metadataPrefix and the returned XML records
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#600">[ date ]</a>
              <a href="thread.html#600">[ thread ]</a>
              <a href="subject.html#600">[ subject ]</a>
              <a href="author.html#600">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Tue, 23 Jul 2002, Jozef Kruger wrote:
&gt;<i> Hello Tim and others,
</I>&gt;<i> 
</I>&gt;<i> &gt; &gt; [set membership in headers]
</I>&gt;<i> &gt; &gt; So my question is, what is the precise use of this new &quot;feature&quot; in 
</I>&gt;<i> &gt; &gt; OAI (of reporting all sets a record occurs in)?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; This allows the set hierachy to be more easily 
</I>&gt;<i> &gt; mirrored/federated. In OAI 1.x the harvester has to query 
</I>&gt;<i> &gt; each set to recreate the set hierachy.
</I>&gt;<i>
</I>&gt;<i> Yes, which results in a minimum number of records that have to be
</I>&gt;<i> fetched, when you would use the setSpec in the reply to GetRecord, you
</I>&gt;<i> would have to fetch every single record, instead of just all the records
</I>&gt;<i> that appear in a set. I don't see how this extra functionality could
</I>&gt;<i> enhance the mirroring of sets. Besides, I would think that you would
</I>&gt;<i> like to define sets without having to change the records that go into
</I>&gt;<i> those sets. Presuming you don't want to do change the records, you would
</I>&gt;<i> always have the same problem as I do, no matter how you represent your
</I>&gt;<i> sets.
</I>
The v2 specification permits complete harvesting of all set information
with just one ListRecords request (with no setSpec). Each record is
harvested precisely once, the header contains all set information. This is
efficient.
 
A change in the set membership of a record is a change in the record. The
datestamp should be changed.
 
&gt;<i> I'd think that using the ListSets followed by a ListRecords on every set
</I>&gt;<i> would be the nicest and most efficient way to (for example) mirror a
</I>&gt;<i> site.
</I>
I each record were in an average of (n) sets then this would result in
harvesting each record (n+1) times (one for each set plus once with
no setspec). That does not sound efficient to me.

&gt;<i> Also, if a set represents a meaningful relation between the records in
</I>&gt;<i> it, it would be logical to first query for the sets and then to get the
</I>&gt;<i> records from a set you're interested in. The other way around doesn't
</I>&gt;<i> make any sense, since you can't search for records on anything but their
</I>&gt;<i> Identifier.
</I>
Bear in mind that sets are designed to permit selective harvesting and the
semantics of sets is not defined within the protocol (use of sets will
likely require direct communication between DP and SP, or community
agreement). The exception to this is mirroring where a mirror might
aim to preserve all set membership information without understanding it.

Unless a repository has some particular application that requires part of
its contents to be harvested then I think it should not, in general,
create an arbitrary collection of sets representing a subject
classification or such. The example I know best is arXiv.org which is
divided into different areas, historically NCSTRL harvested only the 'cs'
(Computer Science) portion of arXiv -- sets provide a way to support this
functionality.

Remember that sets are optional! If they are difficult to implement and
there is no well defined need then I suggest that repositories do not
implement them. For arXiv I think we have a need and I have gone to the
trouble of building and maintaining an extra index similar to the one Tim
described.

Cheers,
Simeon.


&gt;<i> &gt; Thanks for your reaction, awaiting more :)
</I>&gt;<i> 
</I>&gt;<i> Cheers,
</I>&gt;<i> Jozef Kruger
</I>

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000599.html">[OAI-implementers] custom error reporting, records in which sets.
</A></li>
	<LI> Next message: <A HREF="000602.html">[OAI-implementers] metadataPrefix and the returned XML records
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#600">[ date ]</a>
              <a href="thread.html#600">[ thread ]</a>
              <a href="subject.html#600">[ subject ]</a>
              <a href="author.html#600">[ author ]</a>
         </LI>
       </UL>
</body></html>
